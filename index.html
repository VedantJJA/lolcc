<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Loading Arcade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            touch-action: none;
            background-color: #111;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .retro-text {
            text-shadow: 2px 2px 0px #000;
        }

        /* Scanline effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 40;
        }

        /* Status Indicator Pulse */
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }
        
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(248, 113, 113, 0); }
            100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0); }
        }

        .status-online { animation: pulse-green 2s infinite; }
        .status-checking { animation: pulse-red 2s infinite; }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .interactive { pointer-events: auto; }

        /* Game specific grids */
        .grid-bg {
            background-size: 40px 40px;
            background-image:
                linear-gradient(to right, rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,255,255,0.05) 1px, transparent 1px);
        }

        .blink {
            animation: blinker 1s linear infinite;
        }
        @keyframes blinker {
            50% { opacity: 0; }
        }
        
        /* Leaderboard Table */
        .score-table td {
            padding: 4px 8px;
        }
        .score-table tr:first-child {
            color: #fbbf24; /* Gold for 1st */
        }
        .score-table tr:nth-child(2) {
            color: #e5e7eb; /* Silver */
        }
        .score-table tr:nth-child(3) {
            color: #b45309; /* Bronze */
        }
    </style>
</head>
<body>

    <div class="scanlines"></div>

    <!-- UI LAYER -->
    <div id="ui-layer" class="p-4">
        
        <!-- HEADER -->
        <div class="flex justify-between items-start w-full">
            <!-- Score -->
            <div class="text-left">
                <div class="text-4xl font-bold retro-text text-white" id="score-display">0</div>
                <div class="text-xs text-gray-400 mt-1">HIGH: <span id="highscore-display">0</span></div>
            </div>

            <!-- Status Panel -->
            <div class="bg-gray-900 border-2 border-white p-2 rounded shadow-lg interactive bg-opacity-90 w-48 flex flex-col">
                <div class="flex justify-between items-center mb-1">
                    <span class="text-[10px] text-gray-400 uppercase tracking-widest">SERVER</span>
                    <div id="status-dot" class="w-2 h-2 rounded-full bg-red-500 status-checking"></div>
                </div>
                <div id="status-text" class="text-[10px] leading-tight text-right font-mono text-gray-300 mb-1">Pinging...</div>
                
                <button id="go-btn" class="hidden w-full bg-green-600 hover:bg-green-500 text-white py-2 text-[10px] rounded border-b-2 border-green-800 active:border-0 transition-all font-bold">
                    ENTER SITE >>
                </button>
            </div>
        </div>

        <!-- MENUS / OVERLAYS -->
        <div id="center-overlay" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center w-full px-4 interactive">
            
            <!-- MAIN MENU -->
            <div id="main-menu" class="bg-gray-900 border-4 border-white p-6 rounded-lg shadow-2xl max-w-md mx-auto">
                <h1 class="text-2xl text-yellow-400 mb-6 retro-text">WAITING<br>ARCADE</h1>
                <div class="space-y-3">
                    <button onclick="GameManager.selectMode('flappy')" class="w-full bg-blue-600 hover:bg-blue-500 text-white py-3 rounded border-b-4 border-blue-800 active:border-0 text-sm retro-text group">
                        FLAPPY BIRD
                    </button>
                    <button onclick="GameManager.selectMode('snake')" class="w-full bg-green-600 hover:bg-green-500 text-white py-3 rounded border-b-4 border-green-800 active:border-0 text-sm retro-text">
                        SNAKE
                    </button>
                    <button onclick="GameManager.selectMode('tetris')" class="w-full bg-red-600 hover:bg-red-500 text-white py-3 rounded border-b-4 border-red-800 active:border-0 text-sm retro-text">
                        TETRIS
                    </button>
                    <button onclick="GameManager.showLeaderboard()" class="w-full bg-gray-700 hover:bg-gray-600 text-white py-3 rounded border-b-4 border-gray-900 active:border-0 text-sm retro-text mt-4">
                        LEADERBOARD
                    </button>
                </div>
            </div>

            <!-- READY MESSAGE -->
            <div id="ready-msg" class="hidden pointer-events-none">
                <h2 class="text-2xl text-white retro-text blink bg-black bg-opacity-50 p-2 rounded">TAP TO START</h2>
                <p class="text-[10px] text-gray-300 mt-2" id="controls-hint">SWIPE TO MOVE</p>
            </div>

            <!-- GAME OVER -->
            <div id="game-over-msg" class="hidden bg-black bg-opacity-95 p-6 rounded-xl border-2 border-red-500 max-w-sm mx-auto">
                <h1 class="text-3xl font-bold text-red-500 mb-2 retro-text">GAME OVER</h1>
                <div class="text-sm text-gray-400 mb-4">SCORE: <span id="final-score" class="text-white text-xl">0</span></div>
                
                <!-- High Score Input Form -->
                <div id="highscore-form" class="hidden mb-4">
                    <p class="text-yellow-400 text-xs mb-2 blink">NEW TOP 3 RECORD!</p>
                    <input type="text" id="player-initials" maxlength="3" placeholder="AAA" class="bg-gray-800 border-2 border-white text-white text-center text-xl p-2 w-24 uppercase font-mono rounded mb-2">
                    <button id="save-score-btn" class="block w-full bg-green-600 text-white py-2 rounded text-xs">SAVE RECORD</button>
                </div>

                <!-- Mini Leaderboard Display -->
                <div id="mini-leaderboard" class="hidden mb-4 bg-gray-900 p-2 rounded border border-gray-700">
                    <div class="text-xs text-gray-500 mb-2 border-b border-gray-700 pb-1">TOP 3 PLAYERS</div>
                    <table class="w-full text-xs font-mono text-left score-table">
                        <tbody id="mini-lb-body"></tbody>
                    </table>
                </div>

                <div id="go-buttons" class="flex gap-4 justify-center">
                    <button id="menu-btn" class="bg-gray-600 text-white px-4 py-3 rounded border-b-4 border-gray-800 active:border-0 text-xs">MENU</button>
                    <button id="retry-btn" class="bg-white text-black px-6 py-3 rounded border-b-4 border-gray-400 active:border-0 text-xs font-bold">RETRY</button>
                </div>
            </div>

            <!-- LEADERBOARD MODAL -->
            <div id="leaderboard-modal" class="hidden bg-gray-900 border-4 border-white p-6 rounded-lg shadow-2xl max-w-md mx-auto w-full">
                <h1 class="text-xl text-yellow-400 mb-4 retro-text">HALL OF FAME</h1>
                
                <div class="flex gap-2 mb-4 justify-center">
                    <button onclick="Leaderboard.render('flappy')" class="px-2 py-1 text-[10px] bg-blue-900 border border-blue-500 rounded">FLAPPY</button>
                    <button onclick="Leaderboard.render('snake')" class="px-2 py-1 text-[10px] bg-green-900 border border-green-500 rounded">SNAKE</button>
                    <button onclick="Leaderboard.render('tetris')" class="px-2 py-1 text-[10px] bg-red-900 border border-red-500 rounded">TETRIS</button>
                </div>

                <div class="bg-black p-4 rounded border border-gray-700 mb-4 min-h-[150px]">
                    <h3 id="lb-title" class="text-xs text-gray-400 mb-2 text-center uppercase">GAME</h3>
                    <table class="w-full text-sm font-mono score-table">
                        <thead>
                            <tr class="text-gray-600 text-[10px]">
                                <th class="text-left">#</th>
                                <th class="text-left">NAME</th>
                                <th class="text-right">SCORE</th>
                            </tr>
                        </thead>
                        <tbody id="lb-body">
                            <!-- Filled by JS -->
                        </tbody>
                    </table>
                </div>
                <button onclick="GameManager.closeLeaderboard()" class="w-full bg-gray-600 text-white py-2 rounded text-xs">CLOSE</button>
            </div>

        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // CONFIG
        const TARGET_URL = "https://vtopc.onrender.com/login";
        
        // UTILS
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // AUDIO
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(freq, type, duration) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        // --- LEADERBOARD SYSTEM ---
        const Leaderboard = {
            data: JSON.parse(localStorage.getItem('arcade_leaderboard_v1')) || {
                flappy: [{name:'CPU', score:10}, {name:'CPU', score:5}, {name:'CPU', score:2}],
                snake: [{name:'CPU', score:50}, {name:'CPU', score:30}, {name:'CPU', score:10}],
                tetris: [{name:'CPU', score:2000}, {name:'CPU', score:1000}, {name:'CPU', score:500}]
            },

            isHighScore: function(game, score) {
                const scores = this.data[game];
                // Qualified if score >= 3rd place
                return score >= scores[2].score;
            },

            addScore: function(game, name, score) {
                const scores = this.data[game];
                scores.push({name: name.toUpperCase(), score: score});
                scores.sort((a, b) => b.score - a.score); // Descending
                this.data[game] = scores.slice(0, 3); // Keep Top 3
                localStorage.setItem('arcade_leaderboard_v1', JSON.stringify(this.data));
            },

            render: function(game) {
                const body = document.getElementById('lb-body');
                document.getElementById('lb-title').innerText = game.toUpperCase();
                body.innerHTML = '';
                this.data[game].forEach((entry, i) => {
                    body.innerHTML += `
                        <tr>
                            <td>${i+1}</td>
                            <td>${entry.name}</td>
                            <td class="text-right">${entry.score}</td>
                        </tr>
                    `;
                });
            },

            renderMini: function(game) {
                const body = document.getElementById('mini-lb-body');
                body.innerHTML = '';
                this.data[game].forEach((entry, i) => {
                    body.innerHTML += `
                        <tr>
                            <td>${i+1}.</td>
                            <td>${entry.name}</td>
                            <td class="text-right">${entry.score}</td>
                        </tr>
                    `;
                });
            }
        };

        // --- GAME MANAGER ---
        const GameManager = {
            mode: 'MENU', // MENU, READY, FLAPPY, SNAKE, TETRIS, GAMEOVER, LEADERBOARD
            selectedGame: null,
            score: 0,
            inputBlock: 0, 

            selectMode: function(gameMode) {
                if (Date.now() < this.inputBlock) return;
                
                this.selectedGame = gameMode;
                this.mode = 'READY';
                this.score = 0;
                
                // UI Updates
                document.getElementById('main-menu').classList.add('hidden');
                document.getElementById('leaderboard-modal').classList.add('hidden');
                document.getElementById('game-over-msg').classList.add('hidden');
                document.getElementById('ready-msg').classList.remove('hidden');
                
                // Load current high score for display
                const currentHigh = Leaderboard.data[gameMode][0].score;
                document.getElementById('score-display').innerText = '0';
                document.getElementById('highscore-display').innerText = currentHigh;
                
                // Hint Text
                const hint = document.getElementById('controls-hint');
                if (gameMode === 'flappy') hint.innerText = "TAP TO FLY";
                if (gameMode === 'snake') hint.innerText = "SWIPE TO TURN";
                if (gameMode === 'tetris') hint.innerText = "SWIPE MOVE • TAP ROTATE • SPACE DROP";

                // Pre-init visuals
                if (gameMode === 'flappy') FlappyGame.init(true);
                if (gameMode === 'snake') SnakeGame.init(true);
                if (gameMode === 'tetris') TetrisGame.init(true);

                if (gameMode !== 'flappy') document.body.classList.add('grid-bg');
                else document.body.classList.remove('grid-bg');
            },

            showLeaderboard: function() {
                this.mode = 'LEADERBOARD';
                document.getElementById('main-menu').classList.add('hidden');
                document.getElementById('leaderboard-modal').classList.remove('hidden');
                Leaderboard.render('flappy'); // Default view
            },

            closeLeaderboard: function() {
                this.mode = 'MENU';
                document.getElementById('leaderboard-modal').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
            },

            startGame: function() {
                this.mode = this.selectedGame.toUpperCase();
                document.getElementById('ready-msg').classList.add('hidden');
                
                if (this.selectedGame === 'flappy') FlappyGame.active = true;
                if (this.selectedGame === 'snake') SnakeGame.active = true;
                if (this.selectedGame === 'tetris') TetrisGame.active = true;
            },

            over: function() {
                this.inputBlock = Date.now() + 1000; 
                this.mode = 'GAMEOVER';
                playTone(150, 'sawtooth', 0.5);
                
                document.getElementById('final-score').innerText = this.score;
                document.getElementById('game-over-msg').classList.remove('hidden');
                
                // Check Leaderboard Qualification
                const isQualify = Leaderboard.isHighScore(this.selectedGame, this.score);
                
                if (isQualify && this.score > 0) {
                    // Show Input Form, Hide Buttons
                    document.getElementById('highscore-form').classList.remove('hidden');
                    document.getElementById('go-buttons').classList.add('hidden');
                    document.getElementById('mini-leaderboard').classList.add('hidden');
                    
                    // Auto focus input
                    setTimeout(() => document.getElementById('player-initials').focus(), 100);
                } else {
                    // Show Buttons & Mini Board
                    document.getElementById('highscore-form').classList.add('hidden');
                    document.getElementById('go-buttons').classList.remove('hidden');
                    document.getElementById('mini-leaderboard').classList.remove('hidden');
                    Leaderboard.renderMini(this.selectedGame);
                }
            },

            saveScore: function() {
                const name = document.getElementById('player-initials').value || "UNK";
                Leaderboard.addScore(this.selectedGame, name, this.score);
                
                // Update UI
                document.getElementById('highscore-form').classList.add('hidden');
                document.getElementById('go-buttons').classList.remove('hidden');
                document.getElementById('mini-leaderboard').classList.remove('hidden');
                Leaderboard.renderMini(this.selectedGame);
            },

            toMenu: function() {
                if (Date.now() < this.inputBlock) return;
                this.mode = 'MENU';
                document.getElementById('game-over-msg').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
                document.getElementById('ready-msg').classList.add('hidden');
                document.body.classList.remove('grid-bg');
                
                FlappyGame.active = false;
                SnakeGame.active = false;
                TetrisGame.active = false;
            },

            retry: function() {
                if (Date.now() < this.inputBlock) return;
                this.selectMode(this.selectedGame);
            },
            
            addScore: function(points) {
                this.score += points;
                document.getElementById('score-display').innerText = this.score;
            }
        };

        // --- FLAPPY BIRD ENGINE ---
        const FlappyGame = {
            active: false,
            bird: { y: 0, v: 0 },
            pipes: [],
            frame: 0,
            lastJumpTime: 0,
            
            init: function(preview = false) {
                this.active = !preview;
                SnakeGame.active = false; 
                TetrisGame.active = false;
                this.bird = { y: canvas.height/2, v: 0 };
                this.pipes = [];
                this.frame = 0;
                this.lastJumpTime = 0;
            },

            update: function() {
                if (!this.active) return;
                this.frame++;
                this.bird.v += 0.25;
                this.bird.y += this.bird.v;

                if (this.frame % 120 === 0) {
                    this.pipes.push({ x: canvas.width, gapY: Math.random() * (canvas.height - 300) + 50, passed: false });
                }

                for (let i = 0; i < this.pipes.length; i++) {
                    let p = this.pipes[i];
                    p.x -= 3;

                    if ((p.x < 80 && p.x + 60 > 50) && (this.bird.y < p.gapY || this.bird.y + 30 > p.gapY + 180)) {
                        GameManager.over();
                    }

                    if (p.x + 60 < 50 && !p.passed) {
                        p.passed = true;
                        GameManager.addScore(1);
                        playTone(600, 'square', 0.1);
                    }
                }

                if (this.bird.y > canvas.height || this.bird.y < -50) GameManager.over();
                this.pipes = this.pipes.filter(p => p.x > -100);
            },

            draw: function() {
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(50, this.bird.y, 30, 30);
                ctx.fillStyle = '#22c55e';
                this.pipes.forEach(p => {
                    ctx.fillRect(p.x, 0, 60, p.gapY);
                    ctx.fillRect(p.x, p.gapY + 180, 60, canvas.height);
                });
            },

            jump: function() {
                const now = Date.now();
                if (now - this.lastJumpTime < 200) return; 
                this.lastJumpTime = now;
                this.bird.v = -6;
                playTone(300, 'sine', 0.1);
            }
        };

        // --- SNAKE ENGINE ---
        const SnakeGame = {
            active: false,
            grid: 20,
            snake: [],
            food: {},
            dir: { x: 0, y: 0 },
            nextDir: { x: 0, y: 0 },
            frame: 0,
            cols: 0,
            rows: 0,

            init: function(preview = false) {
                this.active = !preview;
                FlappyGame.active = false;
                TetrisGame.active = false;
                
                // Calculate playable grid bounds
                this.cols = Math.floor((canvas.width - 20) / this.grid);
                this.rows = Math.floor((canvas.height - 20) / this.grid);
                
                this.snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
                this.dir = { x: 1, y: 0 };
                this.nextDir = { x: 1, y: 0 };
                this.spawnFood();
            },

            spawnFood: function() {
                this.food = {
                    x: Math.floor(Math.random() * this.cols),
                    y: Math.floor(Math.random() * this.rows)
                };
            },

            update: function() {
                if (!this.active) return;
                this.frame++;
                if (this.frame % 6 !== 0) return;

                this.dir = {...this.nextDir};
                const head = { x: this.snake[0].x + this.dir.x, y: this.snake[0].y + this.dir.y };

                // Border Collision
                if (head.x < 0 || head.x >= this.cols || head.y < 0 || head.y >= this.rows) {
                    GameManager.over();
                    return;
                }

                // Self Collision
                for (let part of this.snake) {
                    if (head.x === part.x && head.y === part.y) {
                        GameManager.over();
                        return;
                    }
                }

                this.snake.unshift(head);
                if (head.x === this.food.x && head.y === this.food.y) {
                    GameManager.addScore(10);
                    playTone(600, 'square', 0.1);
                    this.spawnFood();
                } else {
                    this.snake.pop();
                }
            },

            draw: function() {
                // Draw Boundary Border
                ctx.strokeStyle = '#ef4444'; // Red Border
                ctx.lineWidth = 2;
                ctx.strokeRect(10, 10, this.cols * this.grid, this.rows * this.grid);

                // Offset context to inside border
                ctx.save();
                ctx.translate(10, 10);

                ctx.fillStyle = '#22c55e';
                this.snake.forEach(p => {
                    ctx.fillRect(p.x * this.grid, p.y * this.grid, this.grid - 1, this.grid - 1);
                });

                ctx.fillStyle = '#ef4444';
                ctx.fillRect(this.food.x * this.grid, this.food.y * this.grid, this.grid - 1, this.grid - 1);
                ctx.restore();
            },

            input: function(x, y) {
                if (x !== 0 && this.dir.x !== 0) return;
                if (y !== 0 && this.dir.y !== 0) return;
                this.nextDir = {x, y};
            }
        };

        // --- TETRIS ENGINE ---
        const TetrisGame = {
            active: false,
            grid: 25,
            cols: 10,
            rows: 20,
            board: [],
            piece: null,
            nextPiece: null, 
            offset: {x:0, y:0},
            dropCounter: 0,
            dropInterval: 1000,
            
            shapes: [
                [[0, 0, 0, 0],[1, 1, 1, 1],[0, 0, 0, 0],[0, 0, 0, 0]], // I
                [[1, 1],[1, 1]], // O
                [[0, 1, 0],[1, 1, 1],[0, 0, 0]], // T
                [[1, 0, 0],[1, 1, 1],[0, 0, 0]], // L
                [[0, 0, 1],[1, 1, 1],[0, 0, 0]], // J
                [[0, 1, 1],[1, 1, 0],[0, 0, 0]], // S
                [[1, 1, 0],[0, 1, 1],[0, 0, 0]]  // Z
            ],
            colors: ['#00f0f0', '#f0f000', '#a000f0', '#f0a000', '#0000f0', '#00f000', '#f00000'],

            createPiece: function() {
                const typeId = Math.floor(Math.random() * this.shapes.length);
                const matrix = this.shapes[typeId].map(row => [...row]);
                return {
                    matrix: matrix,
                    pos: {x: (this.cols / 2 | 0) - Math.ceil(matrix[0].length / 2), y: 0},
                    color: this.colors[typeId]
                };
            },

            init: function(preview = false) {
                this.active = !preview;
                FlappyGame.active = false;
                SnakeGame.active = false;
                
                this.offset.x = (canvas.width - (this.cols * this.grid)) / 2;
                this.offset.y = (canvas.height - (this.rows * this.grid)) / 2;
                
                this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                this.nextPiece = this.createPiece(); 
                this.resetPiece();
                this.dropCounter = 0;
            },

            resetPiece: function() {
                this.piece = this.nextPiece;
                this.nextPiece = this.createPiece();
                this.piece.pos = {x: (this.cols / 2 | 0) - 1, y: 0};
                
                if (this.collide(this.board, this.piece)) {
                    GameManager.over();
                }
            },

            collide: function(board, piece) {
                const m = piece.matrix;
                const o = piece.pos;
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        if (m[y][x] !== 0 && (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            },

            merge: function(board, piece) {
                piece.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            board[y + piece.pos.y][x + piece.pos.x] = piece.color;
                        }
                    });
                });
            },

            rotate: function(matrix) {
                for (let y = 0; y < matrix.length; ++y) {
                    for (let x = 0; x < y; ++x) {
                        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                    }
                }
                matrix.forEach(row => row.reverse());
            },

            playerRotate: function() {
                const pos = this.piece.pos.x;
                let offset = 1;
                this.rotate(this.piece.matrix);
                while (this.collide(this.board, this.piece)) {
                    this.piece.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > this.piece.matrix[0].length) {
                        this.rotate(this.piece.matrix);
                        this.piece.pos.x = pos;
                        return;
                    }
                }
            },

            arenaSweep: function() {
                let lines = 0;
                outer: for (let y = this.board.length - 1; y > 0; --y) {
                    for (let x = 0; x < this.board[y].length; ++x) {
                        if (this.board[y][x] === 0) continue outer;
                    }
                    const row = this.board.splice(y, 1)[0].fill(0);
                    this.board.unshift(row);
                    ++y;
                    lines++;
                }
                if (lines > 0) {
                    GameManager.addScore(lines * 100 * lines); // Bonus for multiple lines
                    playTone(400 + (lines * 100), 'sine', 0.2);
                }
            },

            update: function() {
                if (!this.active) return;
                this.dropCounter += 16;
                if (this.dropCounter > this.dropInterval) {
                    this.drop();
                }
            },

            draw: function() {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.offset.x - 2, this.offset.y - 2, (this.cols * this.grid) + 4, (this.rows * this.grid) + 4);
                
                ctx.fillStyle = '#111';
                ctx.fillRect(this.offset.x, this.offset.y, this.cols * this.grid, this.rows * this.grid);

                this.board.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            ctx.fillStyle = value;
                            ctx.fillRect(this.offset.x + x * this.grid, this.offset.y + y * this.grid, this.grid-1, this.grid-1);
                        }
                    });
                });

                if (this.piece) {
                    this.piece.matrix.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value !== 0) {
                                ctx.fillStyle = this.piece.color;
                                ctx.fillRect(this.offset.x + (x + this.piece.pos.x) * this.grid, 
                                             this.offset.y + (y + this.piece.pos.y) * this.grid, 
                                             this.grid-1, this.grid-1);
                            }
                        });
                    });
                }

                // Next Piece
                const previewX = this.offset.x + (this.cols * this.grid) + 20;
                const previewY = this.offset.y;
                ctx.fillStyle = '#fff';
                ctx.font = '10px "Press Start 2P"';
                ctx.fillText("NEXT", previewX, previewY - 10);
                ctx.strokeStyle = '#666';
                ctx.strokeRect(previewX, previewY, 80, 80);
                ctx.fillStyle = '#000';
                ctx.fillRect(previewX, previewY, 80, 80);

                if (this.nextPiece) {
                    const offsetX = previewX + 15;
                    const offsetY = previewY + 15;
                    this.nextPiece.matrix.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value !== 0) {
                                ctx.fillStyle = this.nextPiece.color;
                                ctx.fillRect(offsetX + x * 15, offsetY + y * 15, 14, 14);
                            }
                        });
                    });
                }
            },

            move: function(dir) {
                this.piece.pos.x += dir;
                if (this.collide(this.board, this.piece)) {
                    this.piece.pos.x -= dir;
                }
            },
            
            drop: function() {
                this.piece.pos.y++;
                if (this.collide(this.board, this.piece)) {
                    this.piece.pos.y--;
                    this.merge(this.board, this.piece);
                    this.resetPiece();
                    this.arenaSweep();
                    this.dropCounter = 0;
                } else {
                    this.dropCounter = 0;
                }
            },

            hardDrop: function() {
                while (!this.collide(this.board, this.piece)) {
                    this.piece.pos.y++;
                }
                this.piece.pos.y--; // Step back up
                this.merge(this.board, this.piece);
                this.resetPiece();
                this.arenaSweep();
                this.dropCounter = 0;
                playTone(100, 'square', 0.1); // Thud sound
            }
        };

        // --- MAIN LOOP ---
        function loop() {
            ctx.fillStyle = '#0f0f0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Global Border
            if (GameManager.mode !== 'MENU' && GameManager.mode !== 'LEADERBOARD') {
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 4;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
            }

            // Draw Game
            if (GameManager.mode === 'FLAPPY' || (GameManager.mode === 'READY' && GameManager.selectedGame === 'flappy')) {
                FlappyGame.active ? FlappyGame.update() : null;
                FlappyGame.draw();
            } else if (GameManager.mode === 'SNAKE' || (GameManager.mode === 'READY' && GameManager.selectedGame === 'snake')) {
                SnakeGame.active ? SnakeGame.update() : null;
                SnakeGame.draw();
            } else if (GameManager.mode === 'TETRIS' || (GameManager.mode === 'READY' && GameManager.selectedGame === 'tetris')) {
                TetrisGame.active ? TetrisGame.update() : null;
                TetrisGame.draw();
            }

            requestAnimationFrame(loop);
        }
        loop();

        // --- INPUT HANDLING (SWIPE + KEYBOARD) ---
        
        let touchStartX = 0;
        let touchStartY = 0;

        function handleTouchStart(e) {
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
            
            if (GameManager.mode === 'READY') {
                GameManager.startGame();
                return;
            }
            if (GameManager.mode === 'FLAPPY') FlappyGame.jump();
        }

        function handleTouchEnd(e) {
            if (GameManager.mode !== 'SNAKE' && GameManager.mode !== 'TETRIS') return;
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;

            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            
            if (Math.abs(diffX) < 10 && Math.abs(diffY) < 10) {
                // TAP DETECTED
                if (GameManager.mode === 'TETRIS') TetrisGame.playerRotate();
                return;
            }

            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Horizontal Swipe
                if (diffX > 0) { // Right
                    if (GameManager.mode === 'SNAKE') SnakeGame.input(1, 0);
                    if (GameManager.mode === 'TETRIS') TetrisGame.move(1);
                } else { // Left
                    if (GameManager.mode === 'SNAKE') SnakeGame.input(-1, 0);
                    if (GameManager.mode === 'TETRIS') TetrisGame.move(-1);
                }
            } else {
                // Vertical Swipe
                if (diffY > 0) { // Down
                    if (GameManager.mode === 'SNAKE') SnakeGame.input(0, 1);
                    if (GameManager.mode === 'TETRIS') TetrisGame.drop();
                } else { // Up
                    if (GameManager.mode === 'SNAKE') SnakeGame.input(0, -1);
                }
            }
        }

        window.addEventListener('touchstart', handleTouchStart, {passive: false});
        window.addEventListener('touchend', handleTouchEnd, {passive: false});

        window.addEventListener('keydown', e => {
            // PREVENT KEY HOLDING / SPAMMING
            if (e.repeat) return;
            
            // Allow typing in input
            if (e.target.tagName === 'INPUT') {
                if (e.key === 'Enter') GameManager.saveScore();
                return;
            }

            if (GameManager.mode === 'READY') {
                GameManager.startGame();
                return;
            }
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
            
            if (GameManager.mode === 'FLAPPY') {
                 if (e.code === 'Space') FlappyGame.jump();
            }
            else if (GameManager.mode === 'SNAKE') {
                if (e.key === 'ArrowUp') SnakeGame.input(0, -1);
                if (e.key === 'ArrowDown') SnakeGame.input(0, 1);
                if (e.key === 'ArrowLeft') SnakeGame.input(-1, 0);
                if (e.key === 'ArrowRight') SnakeGame.input(1, 0);
            }
            else if (GameManager.mode === 'TETRIS') {
                if (e.key === 'ArrowLeft') TetrisGame.move(-1);
                if (e.key === 'ArrowRight') TetrisGame.move(1);
                if (e.key === 'ArrowDown') TetrisGame.drop();
                if (e.key === 'ArrowUp') TetrisGame.playerRotate();
                if (e.code === 'Space') TetrisGame.hardDrop();
            }
        });

        document.getElementById('retry-btn').onclick = () => GameManager.retry();
        document.getElementById('menu-btn').onclick = () => GameManager.toMenu();
        document.getElementById('save-score-btn').onclick = () => GameManager.saveScore();

        // --- PINGER SERVICE (FIXED) ---
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const goBtn = document.getElementById('go-btn');
        let isTargetReady = false;

        async function checkServer() {
            if (isTargetReady) return;
            
            try {
                const controller = new AbortController();
                const id = setTimeout(() => controller.abort(), 5000);
                
                // Added Cache Busting
                const bust = Date.now();
                await fetch(`${TARGET_URL}?t=${bust}`, { 
                    mode: 'no-cors', 
                    signal: controller.signal 
                });
                
                clearTimeout(id);
                
                isTargetReady = true;
                statusDot.classList.remove('bg-red-500', 'status-checking');
                statusDot.classList.add('bg-green-500', 'status-online');
                statusText.innerText = "ONLINE";
                statusText.classList.remove('text-gray-300');
                statusText.classList.add('text-green-400', 'font-bold');
                goBtn.classList.remove('hidden');
                goBtn.onclick = () => window.location.href = TARGET_URL;
            } catch (e) {
                console.log("Ping failed (expected if booting)...");
            }
        }
        
        setInterval(checkServer, 5000);
        checkServer(); 

    </script>
</body>
</html>
