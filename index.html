<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Loading...</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            touch-action: none;
            background-color: #111;
            color: white;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .retro-text {
            text-shadow: 2px 2px 0px #000;
        }

        /* Scanline effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
        }

        /* Status Indicator Pulse */
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }
        
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(248, 113, 113, 0); }
            100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0); }
        }

        .status-online {
            animation: pulse-green 2s infinite;
        }
        .status-checking {
            animation: pulse-red 2s infinite;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            z-index: 10;
        }

        .interactive {
            pointer-events: auto;
        }
    </style>
</head>
<body>

    <!-- Visual Overlay Effects -->
    <div class="scanlines"></div>

    <!-- Main UI Layer -->
    <div id="ui-layer">
        <!-- Header: Status Bar -->
        <div class="flex justify-between items-start w-full">
            <!-- Score (Moved to Left to avoid conflict with Status Bar) -->
            <div class="text-left">
                <div class="text-4xl font-bold retro-text" id="score-display">0</div>
                <div class="text-xs text-gray-400 mt-1">HIGH: <span id="highscore-display">0</span></div>
            </div>

            <!-- Status Panel (Moved to Right) -->
            <div class="bg-gray-900 border-2 border-white p-3 rounded shadow-lg interactive bg-opacity-90 max-w-[200px] md:max-w-md">
                <div class="text-xs text-gray-400 mb-1 uppercase tracking-widest text-right">Target Status</div>
                <div id="status-display" class="flex items-center gap-2 justify-end">
                    <span id="status-text" class="text-xs md:text-sm leading-tight text-right">Waking up server...</span>
                    <div id="status-dot" class="w-3 h-3 rounded-full bg-red-500 status-checking shrink-0"></div>
                </div>
                <button id="go-btn" class="hidden mt-3 w-full bg-green-600 hover:bg-green-500 text-white py-2 text-xs rounded border-b-4 border-green-800 active:border-0 active:translate-y-1 transition-all">
                    ENTER APP ->
                </button>
            </div>
        </div>

        <!-- Center: Game Messages / Start Screen -->
        <div id="center-message" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center w-full px-4 interactive">
            
            <!-- Config Panel (Only shows if no URL set) -->
            <div id="config-panel" class="hidden bg-gray-800 border-4 border-white p-6 rounded-lg shadow-2xl max-w-md mx-auto mb-6">
                <h2 class="text-yellow-400 text-lg mb-4 retro-text">SYSTEM CONFIG</h2>
                <p class="text-xs text-gray-300 mb-4 leading-relaxed">
                    Enter the URL of your Render/Heroku app. We will ping it while you play.
                </p>
                <input type="text" id="target-url-input" placeholder="https://my-app.onrender.com" class="w-full bg-gray-900 border border-gray-600 text-white p-3 text-xs mb-4 font-mono focus:outline-none focus:border-yellow-400 rounded">
                <button id="save-config-btn" class="w-full bg-blue-600 hover:bg-blue-500 text-white py-3 text-sm rounded border-b-4 border-blue-800 active:border-b-0 active:mt-1">
                    START SYSTEM
                </button>
            </div>

            <!-- Game Messages -->
            <div id="game-start-msg">
                <h1 class="text-4xl md:text-6xl font-bold text-yellow-400 mb-4 retro-text drop-shadow-lg">FLAPPY<br>WAIT</h1>
                <p class="text-sm md:text-base blink text-white bg-black bg-opacity-50 inline-block px-4 py-2 rounded">PRESS SPACE or TAP</p>
            </div>

            <div id="game-over-msg" class="hidden">
                <h1 class="text-4xl font-bold text-red-500 mb-4 retro-text">GAME OVER</h1>
                <div class="bg-gray-900 border-2 border-white p-4 inline-block rounded mb-4">
                    <div class="text-xs text-gray-400">SCORE</div>
                    <div class="text-2xl text-white mb-2" id="final-score">0</div>
                    <div class="text-xs text-gray-400">BEST</div>
                    <div class="text-xl text-yellow-400" id="final-best">0</div>
                </div>
                <br>
                <button id="restart-btn" class="bg-white text-black px-6 py-3 rounded border-b-4 border-gray-400 hover:bg-gray-200 active:border-0 active:mt-1 font-bold">
                    RETRY
                </button>
            </div>
        </div>

        <!-- Footer -->
        <div class="text-center text-[10px] text-gray-600 pb-2">
            v1.0 // WAITING ROOM
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * CONFIGURATION
         * You can hardcode your URL here to skip the input screen.
         * Example: const HARDCODED_URL = "https://my-cool-app.onrender.com";
         */
        const HARDCODED_URL = "https://vtopc.onrender.com/login"; 

        // --- Game Engine Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive Canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game State
        let frames = 0;
        let score = 0;
        let highScore = localStorage.getItem('flappy_highscore') || 0;
        let gameSpeed = 2.5; // Initial speed
        let gameState = 'START'; // START, PLAYING, GAMEOVER
        let targetUrl = HARDCODED_URL;
        let isTargetReady = false;
        let ignoreInputTimestamp = 0; // Debounce for inputs

        // UI Elements
        const uiScore = document.getElementById('score-display');
        const uiHighScore = document.getElementById('highscore-display');
        const msgStart = document.getElementById('game-start-msg');
        const msgOver = document.getElementById('game-over-msg');
        const finalScore = document.getElementById('final-score');
        const finalBest = document.getElementById('final-best');
        const restartBtn = document.getElementById('restart-btn');
        const configPanel = document.getElementById('config-panel');
        const urlInput = document.getElementById('target-url-input');
        const saveConfigBtn = document.getElementById('save-config-btn');

        // Sound Synthesis (No external assets needed)
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'jump') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'score') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.setValueAtTime(800, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }
        }

        // --- Physics Entities ---

        const bird = {
            x: 50,
            y: 150,
            w: 30,
            h: 30,
            color: '#FACC15', // Tailwind Yellow-400
            velocity: 0,
            gravity: 0.25,
            jumpStrength: 5.5,
            rotation: 0,
            draw: function() {
                ctx.save();
                ctx.translate(this.x + this.w/2, this.y + this.h/2);
                // Rotation based on velocity
                let rot = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));
                ctx.rotate(rot);
                
                // Body
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
                
                // Eye
                ctx.fillStyle = 'white';
                ctx.fillRect(this.w/4, -this.h/2 + 4, 10, 10);
                ctx.fillStyle = 'black';
                ctx.fillRect(this.w/4 + 4, -this.h/2 + 6, 4, 4);
                
                // Beak
                ctx.fillStyle = '#F97316'; // Orange
                ctx.fillRect(this.w/2, 0, 8, 6);
                
                // Wing
                ctx.fillStyle = '#EAB308'; // Darker yellow
                ctx.fillRect(-this.w/4, 2, 16, 10);

                ctx.restore();
            },
            update: function() {
                this.velocity += this.gravity;
                this.y += this.velocity;

                // Floor collision
                if (this.y + this.h >= canvas.height - 20) { // -20 for ground offset
                    this.y = canvas.height - 20 - this.h;
                    gameOver();
                }
                
                // Ceiling collision
                if (this.y < 0) {
                    this.y = 0;
                    this.velocity = 0;
                }
            },
            jump: function() {
                this.velocity = -this.jumpStrength;
                playSound('jump');
            }
        };

        const pipes = {
            items: [],
            width: 60,
            gap: 170,
            dx: 2.5, // Must match gameSpeed
            timer: 0,
            draw: function() {
                ctx.fillStyle = '#22c55e'; // Green-500
                ctx.strokeStyle = '#14532d'; // Green-900
                ctx.lineWidth = 3;

                for (let i = 0; i < this.items.length; i++) {
                    let p = this.items[i];
                    
                    // Top Pipe
                    ctx.fillRect(p.x, 0, this.width, p.top);
                    ctx.strokeRect(p.x, 0, this.width, p.top);
                    // Top Cap
                    ctx.fillRect(p.x - 4, p.top - 20, this.width + 8, 20);
                    ctx.strokeRect(p.x - 4, p.top - 20, this.width + 8, 20);

                    // Bottom Pipe
                    ctx.fillRect(p.x, canvas.height - p.bottom, this.width, p.bottom);
                    ctx.strokeRect(p.x, canvas.height - p.bottom, this.width, p.bottom);
                    // Bottom Cap
                    ctx.fillRect(p.x - 4, canvas.height - p.bottom, this.width + 8, 20);
                    ctx.strokeRect(p.x - 4, canvas.height - p.bottom, this.width + 8, 20);
                }
            },
            update: function() {
                // Add new pipe
                if (frames % 150 === 0) { // Roughly every 2.5 seconds
                    // Randomize gap position
                    let maxTop = canvas.height - this.gap - 100; // 100 is min bottom pipe height
                    let topHeight = Math.floor(Math.random() * (maxTop - 50)) + 50; // 50 is min top pipe height
                    
                    this.items.push({
                        x: canvas.width,
                        top: topHeight,
                        bottom: canvas.height - this.gap - topHeight,
                        passed: false
                    });
                }

                for (let i = 0; i < this.items.length; i++) {
                    let p = this.items[i];
                    p.x -= this.dx;

                    // Collision Detection
                    // 1. X-axis overlap
                    if (bird.x + bird.w > p.x && bird.x < p.x + this.width) {
                        // 2. Y-axis overlap (Top pipe OR Bottom pipe)
                        if (bird.y < p.top || bird.y + bird.h > canvas.height - p.bottom) {
                            gameOver();
                        }
                    }

                    // Score point
                    if (p.x + this.width < bird.x && !p.passed) {
                        score++;
                        
                        // --- DIFFICULTY SCALING ---
                        gameSpeed += 0.08; // Harder: Speed increases faster (was 0.05)
                        this.dx = gameSpeed;

                        // Harder: Shrink the gap every 5 points, down to a limit
                        if (score % 5 === 0 && this.gap > 130) {
                            this.gap -= 8; 
                        }

                        p.passed = true;
                        uiScore.innerText = score;
                        playSound('score');
                        
                        // Visual feedback
                        uiScore.style.transform = "scale(1.5)";
                        setTimeout(() => uiScore.style.transform = "scale(1)", 100);
                    }

                    // Remove off-screen pipes
                    if (p.x + this.width < 0) {
                        this.items.shift();
                        i--;
                    }
                }
            },
            reset: function() {
                this.items = [];
                this.dx = 2.5;
                this.gap = 170; // Reset gap to initial easy size
            }
        };

        // --- Background Decoration ---
        const clouds = {
            items: [],
            draw: function() {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                for(let c of this.items) {
                    ctx.fillRect(c.x, c.y, c.w, c.h);
                }
            },
            update: function() {
                if(Math.random() < 0.01) {
                    this.items.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height/2),
                        w: 50 + Math.random() * 100,
                        h: 20 + Math.random() * 30,
                        speed: 0.5 + Math.random() * 1
                    });
                }
                for(let i=0; i<this.items.length; i++) {
                    this.items[i].x -= this.items[i].speed;
                    if(this.items[i].x + this.items[i].w < 0) {
                        this.items.shift();
                        i--;
                    }
                }
            }
        }

        // --- Game Loop ---

        function loop() {
            // Background
            ctx.fillStyle = '#1a1a1a'; // Dark Gray
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ground
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 20);

            clouds.update();
            clouds.draw();

            if (gameState === 'PLAYING') {
                bird.update();
                pipes.update();
                frames++;
            }

            pipes.draw();
            bird.draw();

            // Ground stripe animation
            ctx.fillStyle = '#4b5563';
            let groundOffset = (frames * gameSpeed) % 20;
            for(let i=0; i<canvas.width; i+=20) {
                ctx.fillRect(i - groundOffset, canvas.height-20, 10, 20);
            }

            requestAnimationFrame(loop);
        }

        // --- Control Logic ---

        function resetGame() {
            bird.y = 150;
            bird.velocity = 0;
            pipes.reset();
            score = 0;
            frames = 0;
            gameSpeed = 2.5;
            uiScore.innerText = '0';
            gameState = 'START';
            
            // Reset UI visibility
            msgStart.style.display = 'block';
            
            // FIX: Correctly hide the Game Over screen
            msgOver.style.display = 'none'; 
            msgOver.classList.add('hidden');
            
            // Prevent immediate jump processing
            ignoreInputTimestamp = Date.now() + 200;

            // Initial render
            bird.draw();
        }

        function startGame() {
            if (Date.now() < ignoreInputTimestamp) return;
            
            gameState = 'PLAYING';
            msgStart.style.display = 'none';
            msgOver.style.display = 'none'; // Safety check
            msgOver.classList.add('hidden');
            configPanel.classList.add('hidden');
            bird.jump();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            playSound('hit');
            
            // Cooldown to prevent accidental restart spamming
            ignoreInputTimestamp = Date.now() + 500;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flappy_highscore', highScore);
            }
            
            uiHighScore.innerText = highScore;
            finalScore.innerText = score;
            finalBest.innerText = highScore;
            
            msgOver.classList.remove('hidden');
            msgOver.style.display = 'block';
        }

        function handleInput(e) {
            // If clicking buttons or inputs, don't trigger game
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            
            // Global input debounce
            if (Date.now() < ignoreInputTimestamp) return;

            if (gameState === 'START') {
                // Only start if URL is set or config is hidden
                if (targetUrl || configPanel.classList.contains('hidden')) {
                     startGame();
                }
            } else if (gameState === 'PLAYING') {
                bird.jump();
            } else if (gameState === 'GAMEOVER') {
                // Allow tapping anywhere to restart (optional quality of life)
                resetGame();
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault(); 
                if (gameState === 'GAMEOVER') {
                    if (Date.now() > ignoreInputTimestamp) resetGame();
                }
                else handleInput(e);
            }
        });
        window.addEventListener('touchstart', (e) => {
            handleInput(e);
        }, {passive: false});
        window.addEventListener('mousedown', handleInput);

        restartBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent click from triggering jump immediately
            resetGame();
        });

        // --- URL Configuration Logic ---

        function initConfig() {
            if (targetUrl) {
                // If hardcoded, skip setup
                startPingService();
            } else {
                // Show setup
                configPanel.classList.remove('hidden');
                msgStart.style.display = 'none';
            }
        }

        saveConfigBtn.addEventListener('click', () => {
            const val = urlInput.value.trim();
            if (val) {
                targetUrl = val.startsWith('http') ? val : `https://${val}`;
                configPanel.classList.add('hidden');
                msgStart.style.display = 'block';
                startPingService();
            }
        });

        // --- Pinger Service (Status Checker) ---
        
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const goBtn = document.getElementById('go-btn');

        function startPingService() {
            statusText.innerText = "Pinging server...";
            
            // Initial check
            checkServer();
            
            // Poll every 5 seconds
            setInterval(checkServer, 5000);
        }

        async function checkServer() {
            if (isTargetReady) return;

            try {
                statusText.innerText = "Waking up Render...";
                
                // We use no-cors because we just want to know if it accepts connection.
                // Render apps usually timeout if they are spinning up (or 503).
                // Once they return ANY header (even opaque), they are technically 'up'.
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout

                await fetch(targetUrl, { 
                    mode: 'no-cors',
                    signal: controller.signal 
                });
                
                clearTimeout(timeoutId);
                
                // If we get here, the server responded (opaque or not)
                serverIsUp();

            } catch (error) {
                // If it times out or fails network check, it's likely still booting or down
                console.log("Ping failed, retrying...", error);
            }
        }

        function serverIsUp() {
            isTargetReady = true;
            
            // UI Updates
            statusDot.classList.remove('bg-red-500', 'status-checking');
            statusDot.classList.add('bg-green-500', 'status-online');
            
            statusText.innerText = "SERVER READY!";
            statusText.classList.add('text-green-400', 'font-bold');
            
            goBtn.classList.remove('hidden');
            goBtn.onclick = () => {
                window.location.href = targetUrl;
            };
        }

        // --- Init ---
        uiHighScore.innerText = highScore;
        initConfig();
        loop();

    </script>
</body>
</html>